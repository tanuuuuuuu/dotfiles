# サブエージェント設計原則

## 1. 焦点を1つに絞る

1サブエージェント = 1責務。複数の無関連な責務を混ぜない。

```
# 悪い例
name: utility-agent
description: コードレビュー、テスト実行、デプロイを行う

# 良い例
name: code-reviewer
description: コード品質・セキュリティを専門レビュー
```

## 2. 具体的な説明を書く

description は Claude が委譲判断に使う唯一の情報。曖昧な説明では適切にトリガーされない。

```yaml
# 悪い例
description: コードを確認する

# 良い例
description: コード品質・セキュリティ・保守性を専門レビュー。PR作成前やコード変更後に使用。具体的な修正案を提示。
```

**含めるべき情報:**
- 何をするか（機能）
- いつ使うか（トリガー条件）
- 何を返すか（出力の特徴）

## 3. 最小限のツール権限

必要なツールのみ許可し、不要なツールは明示的に除外する。

```yaml
# レビュアー（読み取り専用）
tools: Read, Grep, Glob
disallowedTools: Write, Edit

# テスト実行（コマンド実行のみ）
tools: Bash, Read
```

**権限設計の指針:**
- 読み取り専用タスク → Write, Edit を除外
- 実行専用タスク → 必要なコマンドのみ許可
- 調査タスク → Explore エージェントを使用

## 4. 適切なモデル選択

| モデル | 用途 | コスト・速度 |
|--------|------|-------------|
| `haiku` | 高速検索、軽い分析、パターンマッチ | 低コスト・高速 |
| `sonnet` | バランス型、通常のコーディング | 中コスト・中速 |
| `opus` | 複雑な推論、アーキテクチャ設計 | 高コスト・低速 |
| 未指定 | メイン会話から継承 | - |

## 5. コンテキスト効率

サブエージェントは独立コンテキストで実行され、メイン会話のコンテキストを消費しない。大量のファイル読み取りや verbose な出力が予想されるタスクはサブエージェントに委譲する。

## スキル vs サブエージェント の判断

| 判断軸 | スキル | サブエージェント |
|--------|--------|-----------------|
| 大量ファイル読み取り | 不向き | 適切 |
| 知識・ガイドラインの参照 | 適切 | 不向き |
| メイン会話と密に連携 | 適切 | 不向き |
| 隔離実行が必要 | 不向き | 適切 |
| コンテキスト節約 | 不向き | 適切 |

## 制約事項

- **サブエージェントは別のサブエージェントを呼べない**（無限ネスト防止）
- 複雑なワークフローはメイン会話で複数サブエージェントをチェーン
